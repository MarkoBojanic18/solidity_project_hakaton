// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

contract Patient{
    address private id_account;  //address of patient
    string private first_name;   //first name of patient
    string private last_name;    //last name of patinet
    string private password;     //password
    string private gender;         //gender {male,female}
    string private year_of_birth;    // in format {1999}
    string private unique_in;         //JMBG
    string private blood_type;       // {A+, A-, B+, B-, AB+, AB-, O+, O-}
    string private height;             // in format 185 (measure will be cm}
    string private weight;               // in fromat 80 (measur will be kg}
    address private mainDoctor;         // address of the patient's main doctor
    address[] private doctors_with_access;   // list of the doctors which can see patient's medical records
    EmergencyPerson private emergencyPerson;   //a person who will be contacted if it is neccessary to make a decision instead of patient
    Insurance[] private insurances;            //list of insurances which patinet takes
    Immunisation[] private immunisations;        //list of immunisations which patient got
    bool private donor;                         //if patient is donor {true, false}
    string[] private donations;               // list of organs which patient will donate
    MedicalRecord[] private medicalRecords;            //list of insurances which patinet takes
    uint256 counterMedicalRecord = 0;                
    
    struct EmergencyPerson{
        string first_name;  // first name of emergency person
        string last_name;   // last name of emergency person
        string contact;    // phone number of emergency person
    }

    struct MedicalRecord{
    uint256  id; // unique identification number of medical record
    string  typeOfRecord; //da li je operacija, alergija, hronicna bolest, povreda
    string  description; //doktorova zapazanja
    address  doctorSignature; //adresa doktora koji je napravio record
    uint256  date_time_of_record; //datum kada je napravljen record
    string  recipe; // recept
    address  patient; // address of patiente
    address doctorWhoCanSeeRecipe; //person in pharmacy who can see patiente's recipe
    }

    struct Insurance{
         string typeOfInsurance;  //type of insurance {life, non-life,...}
        string insuranceCoverage; // coverage of insurance {legs, arms, body, heartattack,...}
        bool insuranceIsPaid; // when patient chooses one insurance it will be false, but when patient pays it then it will becomes true
    } 

    struct Immunisation{
        string typeOfImmun;     //type/name of immunisation which patient got
        uint256 date_time_of_imun;  //date and time when patient got immunisation
    }

    constructor (address id, string memory _first_name, string memory _last_name, string memory _password, string memory _gender, string memory _year_of_birth, string memory _unique_in, string memory _blood_type, string memory _height, string memory _weight){
        id_account = id;
        first_name = _first_name;
        last_name = _last_name;
        password = _password;
        gender = _gender;
        year_of_birth = _year_of_birth;
        unique_in = _unique_in;
        blood_type = _blood_type;
        height = _height;
        weight = _weight;
        donor = false;
    }

    function getPatienceAccount() public view returns(address){
        return id_account;
    }

    function setPatienceAccount(address id) public {
        id_account = id;
    }

    function getPatienceFirstName() public view returns(string memory){
        return first_name;
    }

    function setPatienceFirstName(string memory fn) public {
        first_name = fn;
    }

    function getPatienceLastName() public view returns(string memory){ 
        return last_name;
    }

    function setPatienceLastName(string memory ln) public {
        last_name = ln;
    }

    function getPatiencePassword() public view returns(string memory){ 
        return password;
    }

    function setPatiencePassword(string memory pass) public {
        password = pass;
    }

    function getPatienceGender() public view returns(string memory){ 
        return gender;
    }

    function setPatienceGender(string memory gend) public {
        gender = gend;
    }

    function getPatienceYearOfBirth() public view returns(string memory){ 
        return year_of_birth;
    }

    function setPatienceYearOfBirth(string memory year) public {
        year_of_birth = year;
    }

    function getUniqueIdentificationNumber() public view returns(string memory){ 
        return unique_in;
    }

    function setUniqueIdentificationNumber(string memory uin) public {
        unique_in = uin;
    }

function getBloodType() public view returns(string memory){ 
        return blood_type;
    }

    function setBloodType(string memory _blood_type) public {
        blood_type = _blood_type;
    }

    function getHeight() public view returns(string memory){ 
        return height;
    }

    function setHeight(string memory _height) public {
        height = _height;
    }

    function getWeight() public view returns(string memory){ 
        return weight;
    }

    function setWeight(string memory _weight) public {
        weight = _weight;
    }

     function getMainDoctor() public view returns(address){ 
        return mainDoctor;
    }

    function setMainDoctor(address mainDoc) public {
        mainDoctor = mainDoc;
    }

     function getAllDoctorsWithAccess() public view returns(address[] memory){ 
        return doctors_with_access;
    }


    //this function only checks for another functions if doctor is in the list and returns false
    // if it isn't and true if doctor is in the list.
    function doesDoctorWithAccessExistInTheList(address doctor) private view returns(bool){
         uint arrayLength = doctors_with_access.length;

        for(uint i = 0; i < arrayLength; i++){
            if(doctors_with_access[i] == doctor){
                return true;
            }
        }

        return false;
    }

    //this function adds doctor to the list of doctors which can access patient's medical records
    //if doctor hasn't been already added to the list.
    function addDoctorWithAccess(address doctor) public {
       if(!doesDoctorWithAccessExistInTheList(doctor)){
        doctors_with_access.push(doctor);
       }
    }

    //this function throws doctor from the list of doctors who can see patient's medical record.
    function throwDoctorFromTheListWithAccess(address doctor)public{
       uint arrayLength = doctors_with_access.length;

        for(uint i = 0; i < arrayLength; i++) {
        if(doctors_with_access[i] == doctor) {
            // Remove the doctor from the array
            // Move the last element to the position to be deleted
            doctors_with_access[i] = doctors_with_access[arrayLength - 1];
            // Remove the last element
            doctors_with_access.pop();
            return; // Exit the function once the doctor is removed
        }
    }
    }

    function getEmergencyPerson() public view returns (EmergencyPerson memory) {
        return emergencyPerson;
    }

     function setEmergencyPerson(
        string memory _firstName,
        string memory _lastName,
        string memory _contact
    ) public {
        emergencyPerson = EmergencyPerson(_firstName, _lastName, _contact);
    }


    function addInsuranceToTheList(string memory _typeOfInsurance, string memory _insuranceCoverage) public  {
            Insurance memory insurance = Insurance(_typeOfInsurance,_insuranceCoverage,false);
            insurances.push(insurance);
    }

    function getInsurancesList() public view returns(Insurance[] memory){
            return insurances;
    }

    function addDonationToTheList(string memory organ) public  {
            donations.push(organ);
            setDonor(true);
    }

    function getDonationsList() public view returns(string[] memory){
            return donations;
    }

    function getDonor() public view returns(bool) {
        return donor;
    }

     function setDonor(bool _donor) public{ 
       donor = _donor;
    }



    function addImmunisationToTheList(string memory _typeOfImmun) public  {
        uint256 _date_time_of_imun = block.timestamp;
            Immunisation memory immunisation = Immunisation(_typeOfImmun,_date_time_of_imun);
            immunisations.push(immunisation);
    }

    function getImmunisationList() public view returns(Immunisation[] memory){
            return immunisations;
    }

    function getAllMedicalRecords() public view returns(MedicalRecord[] memory){
        return medicalRecords;
    }

    function addMecialRecordForPatient(string memory _typeOfRecord, string memory _description, address  _doctorSignature, string memory _recipe, address _patient, address _doctorWhoCanSeeRecipe ) public {
        counterMedicalRecord++;
        uint256 _date_time_of_record = block.timestamp;
        MedicalRecord memory medicalRecord = MedicalRecord(counterMedicalRecord, _typeOfRecord, _description, _doctorSignature, _date_time_of_record, _recipe,  _patient, _doctorWhoCanSeeRecipe);
        medicalRecords.push(medicalRecord);
    }

    function changeMedicalRecord(uint256 _id, address _doctorWhoCanSeeRecipe) public{
        uint256 arrayLength = medicalRecords.length;

        for (uint256 i = 0; i < arrayLength; i++) {
        if (medicalRecords[i].id == _id) {
            medicalRecords[i].doctorWhoCanSeeRecipe = _doctorWhoCanSeeRecipe;
        }
    }
    }

    function getMedicalRecordByDaignose(string memory _diagnose) public view returns(MedicalRecord[] memory){
       uint256 arrayLength = medicalRecords.length;
    MedicalRecord[] memory diagnoseMedicalRecord = new MedicalRecord[](arrayLength);
    uint256 count = 0;

    for (uint256 i = 0; i < arrayLength; i++) {
        if (keccak256(bytes(medicalRecords[i].typeOfRecord)) == keccak256(bytes(_diagnose))) {
            // If the category matches, add the expense to the result array
            diagnoseMedicalRecord[count] = medicalRecords[i];
            count++;
        }
    }

     // Resize the array to remove any uninitialized elements
    assembly {
        mstore(diagnoseMedicalRecord, count)
    }

    return diagnoseMedicalRecord;
    }

    


}